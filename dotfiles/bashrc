# Settings for all shells
# Set various aliases and functions

alias grep='grep -I'
alias hig='history | grep -i'
alias ls='ls -FG'       # ls always shows colour and type (dir, link, etc)
alias la='ls -aFG'      # Like above but shows dotfiles/-directories
alias ll='ls -lhoAFG'   # Show file flags in long mode with human readable size
alias lg='ls -lhoAFG | grep -i' # Case insensitive grep on ls
alias ulimit='ulimit -S'
alias more='less'
alias ghci='ghci -ignore-dot-ghci -ghci-script ~/.ghci'

if [[ -n "$BASH_VERSION" ]] && [[ -n "$PS1" ]]; then
    TITLEBAR="\[\e]0;\u@\h:\w\007\]" # Sets titlebar of xterm/PuTTy to \u@\h:\w
    CAPTION="\[\e]0;\w\007\]"        # Sets screen status bar to CWD
    JOBS="\[\e[0;36m\]"              # Bright cyan, no. of background jobs
    EXIT="\[\e[0;31m\]"              # Bright red, error exit code
    TIME="\[\e[1;37m\]"              # Bright white, clock colours
    CWD="\[\e[1;34m\]"               # Pale blue, top directory
    CLEAR="\[\e[0m\]"                # Clear colour changes

    if [[ $UID -eq 0 ]]; then
        USERCOLOR="\[\e[0;31m\]"     # Red if running as root
    else
        USERCOLOR="\[\e[0;32m\]"     # Green otherwise
    fi

    prompt_status ()
    {
        local status=$?
        [[ $status = 0 ]] && return
        echo -n " $status"
    }

    # Default prompt (for TMUX)
    PS1="$USERCOLOR\u $CWD\W $JOBS\j$EXIT\$(prompt_status)$CLEAR\$ "

    if [[ "$TERM" =~ cons* ]]; then
        # Prompt when running on console
        PS1="$TIME\$(date "+%H:%M") $PS1"
    elif [[ -n "$STY" ]]; then
        # Add caption to set the CWD in screen's statusbar
        PS1="$CAPTION$PS1"
    elif [[ "$TERM" =~ screen* && -z "$TMUX" ]]; then
        # Prompt when running in a remote screen
        PS1="$USERCOLOR\u@\h $CWD\W $JOBS\j$EXIT\$(prompt_status)$CLEAR\$ "
    elif [[ -z "$TMUX" ]]; then
        # Set terminal titlebar to user@host:path for all other terminals
        PS1="$TITLEBAR$TIME\$(date "+%H:%M") $PS1"
    fi

    # Set various shell options
    shopt -s no_empty_cmd_completion
    shopt -s nocaseglob   # * matches case insensitively
    shopt -s extglob      # Enable extended bash patterns
    shopt -s histreedit   # Edit line on failed history substitution
    shopt -s cmdhist      # Multi-line command are stored multi-line in history
    shopt -s lithist      # Store multi-line history entries with s/;/\n
    shopt -s checkwinsize # Check terminal size after each command
    set -o vi             # Set vi keybindings.

    # Commands (colon separated) not added to the history
    HISTIGNORE="fortune*:history*" # Stop me from wasting time on fortune!
    HISTTIMEFORMAT='%H:%M ' # Fixes multiline command history
    HISTCONTROL=ignorespace
    HISTSIZE=1000000      # Number of history lines to keep
    if [[ "${BASH_VERSINFO[0]:-0}" -lt 4 ]] \
    || { [[ "${BASH_VERSINFO[0]:-0}" -eq 4 ]] \
         && [[ "${BASH_VERSINFO[1]}" -lt 4 ]] \
       ;} || ! type sync_history >/dev/null 2>&1
    then
        export HISTFILE="$HOME/.bash_history"
        shopt -s histappend   # Append to .bash_history instead of overwriting
    else
        unset HISTFILE
        hist_path="$(sync_history history-path)"
        history -cr "$hist_path"
        last_cmd_no ()
        {
            last_cmd=$(HISTTIMEFORMAT='	' history 1)
            # Silence warning about $? since this is intended to check the
            # result of interactive commands in the shell.
            # shellcheck disable=SC2181
            if [[ $? -eq 0 ]] && [[ -n "$last_cmd" ]]; then
                last_cmd="${last_cmd##*( )}"
                last_cmd="${last_cmd%%	*}"
            else
                last_cmd="0"
            fi
        }

        last_cmd_no
        prompt_command ()
        {
            local old="$last_cmd"
            local reset=""
            last_cmd_no

            if [[ "$old" -ne "$last_cmd" ]]; then
                local cmd
                cmd=$(HISTTIMEFORMAT='	' history 1)
                cmd=${cmd##*	}
                history -d "$last_cmd"
                sync_history update $$ "$cmd" >~/.hist-update.$$
                reset=$?
                unset cmd
            else
                sync_history update $$ >~/.hist-update.$$
                reset=$?
            fi

            history -r ~/.hist-update.$$
            rm ~/.hist-update.$$

            if [[ $reset -eq 2 ]]; then
                local hist_path
                hist_path="$(sync_history history-path)"
                history -cr "$hist_path"
            fi
            last_cmd_no
        }
        PROMPT_COMMAND="prompt_command; $PROMPT_COMMAND"
        trap 'sync_history deregister $$' EXIT
    fi

    if [[ -f /usr/local/etc/bash_completion ]]; then
        # shellcheck disable=SC1091
        . /usr/local/etc/bash_completion
    fi

    if [[ -f /opt/homebrew/etc/profile.d/bash_completion.sh ]]; then
        # shellcheck disable=SC1091
        . /opt/homebrew/etc/profile.d/bash_completion.sh
    fi

    # Set OS specific aliases and settings or overwrites
    os_name="$(uname)"
    if [[ "$os_name" = "Darwin" ]]; then
        num_cpus="$(/usr/sbin/sysctl -n hw.ncpu)"
        # Silence warning that this expands at define time. We don't expect the
        # number of CPUs to change at runtime....
        # shellcheck disable=SC2139
        alias make="make -rj$num_cpus"

        rcopy ()
        {
            ssh -q "$1" tmux save-buffer -b "${2:-0}" - | pbcopy
        }

        rpaste ()
        {
            pbpaste | ssh -q "$1" tmux load-buffer -b "${2:-0}" -
        }

    elif [[ "$os_name" = "FreeBSD" ]]; then
        alias rm='rm -rI' # (Recursively) delete and ask confirmation for >3 files
        if [[ -f /usr/local/share/mercurial/contrib/bash_completion ]]; then
            # Silence warning that this file does not exist, since it only
            # exists on FreeBSD.
            # shellcheck disable=SC1091
            . /usr/local/share/mercurial/contrib/bash_completion
        fi
    elif [[ "$os_name" = "Linux" ]]; then
        num_cpus="$(awk '/^processor/{n+=1}END{print n}' /proc/cpuinfo)"
        # Silence warning that this expands at define time. We don't expect the
        # number of CPUs to change at runtime....
        # shellcheck disable=SC2139
        alias make="make -rj$num_cpus"
        alias ls='ls -F --color=auto'
        alias la='ls -aF --color=auto'
        alias ll='ls -lhoAF --color=auto'
        alias lg='ls -lhoAF --color=auto | grep -i'
    fi

    if ! type rg >/dev/null 2>&1; then
        rg () {
            grep --color=always -r ${1+"$@"} --exclude-dir=.hg --exclude-dir=dist --exclude-dir=dist-newstyle --exclude-dir=.build --exclude=tags . | less -FRX
        }
    else
        rg () {
            command rg --color=always ${1+"$@"} | less -FRX
        }
    fi
fi

rlist ()
{
    ssh -q "$1" tmux list-buffers
}

symbolrg () {
    find -E . -regex ".*\.(a|dylib|so)" -exec symbolgrep {} "$@" \; | less -FSXR
}

st () {
    if [[ -n "$TMUX" ]]; then
        tmux renamew "$*"
    else
        echo -ne "\033k$*\033\\"
    fi
}

refresh () {
    if [[ -n "$TMUX_REFRESH_VARS" ]]; then
        for var in ${TMUX_REFRESH_VARS//:/$IFS}; do
            local val
            if val="$(tmux show-environment "$var")"; then
                export "${val?}"
            fi
        done
    fi
}

reload () {
    . "$HOME/.bash_env"
    refresh
}

# Read and set any machine local overrides
# Stop shellcheck from checking file, it may not exist
# shellcheck disable=SC1090
[[ -f ~/.bashrc_local ]] && . ~/.bashrc_local

# Clear any failed status from command ran during initialisation
true
